<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Single φ-spiral band on torus (R=1, r=1)</title>
<style>
  html,body{height:100%;margin:0;background:#081024;color:#e7eaee;font:14px ui-sans-serif,system-ui,-apple-system}
  #app{position:fixed;inset:0}
  .ui{position:fixed;top:12px;left:12px;background:rgba(15,22,32,.92);border:1px solid #233244;border-radius:12px;
      padding:12px;display:grid;gap:10px;min-width:640px}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .row label{color:#9fb1c7}
  .row input[type="range"]{flex:1}
  .row output{min-width:64px;text-align:right;color:#ffd66b}
  button{background:#0f1725;border:1px solid #2c4461;color:#e7eaee;padding:6px 10px;border-radius:8px;cursor:pointer}
  button:hover{border-color:#446c96}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #2c4461;border-radius:999px;background:#0f1725}
  .small{font-size:12px;color:#9fb1c7;line-height:1.35}
</style>
</head>
<body>
<div id="app"></div>

<div class="ui">
  <div class="small">
    Single <b>φ-spiral band</b> painted exactly on a horn torus (<b>R=1, r=1</b>).<br>
    <b>Turns = 2</b>, width profile: <code>w(v)=lerp(0, 0.897597901, (1+cos v)/2)</code>.
  </div>

  <div class="row">
    <label>Around factor</label>
    <input id="uScale" type="range" min="1.00" max="2.00" step="0.01" value="1.00">
    <output id="uOut">1.00</output>

    <label>Opacity</label>
    <input id="opacity" type="range" min="0.00" max="1.00" step="0.01" value="1.00">
    <output id="opacityOut">1.00</output>
  </div>

  <div class="row">
    <label>Spin (°/s)</label>
    <input id="spinSpeed" type="range" min="0" max="180" step="1" value="18">
    <output id="spinOut">18</output>

    <label>Color cycle (°/s)</label>
    <input id="hueSpeed" type="range" min="0" max="360" step="1" value="60">
    <output id="hueOut">60</output>
  </div>

  <div class="row">
    <label class="pill"><input id="showTorus" type="checkbox" checked> Torus wire guide</label>
    <button id="resetView">Reset view</button>
    <button id="lookZ">Look +Z</button>
    <button id="lookX">Look +X</button>
    <button id="lookY">Look +Y</button>
  </div>
</div>

<!-- Import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

/* Constants */
const PHI=(1+Math.sqrt(5))/2;
const k_phi=Math.log(PHI)/(Math.PI/2);
const R=1.0, r=1.0;                     // fixed horn torus
const TURNS=2;                          // fixed
const WMAX=0.897597901;                 // max world width at outer rim
const TWO_PI=Math.PI*2;

/* UI */
const $=id=>document.getElementById(id);
const ui={
  uScale:$('uScale'), opacity:$('opacity'), showTorus:$('showTorus'),
  spinSpeed:$('spinSpeed'), hueSpeed:$('hueSpeed'),
  uOut:$('uOut'), opacityOut:$('opacityOut'), spinOut:$('spinOut'), hueOut:$('hueOut'),
  resetView:$('resetView'), lookZ:$('lookZ'), lookX:$('lookX'), lookY:$('lookY')
};
function syncOut(){
  ui.uOut.textContent=(+ui.uScale.value).toFixed(2);
  ui.opacityOut.textContent=(+ui.opacity.value).toFixed(2);
  ui.spinOut.textContent=(+ui.spinSpeed.value);
  ui.hueOut.textContent=(+ui.hueSpeed.value);
}

/* Scene */
const scene=new THREE.Scene(); scene.background=new THREE.Color(0x081024);
const camera=new THREE.PerspectiveCamera(56, innerWidth/innerHeight, 0.01, 2000); camera.position.set(4.8,3.8,5.0);
const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setPixelRatio(Math.min(devicePixelRatio,2)); renderer.setSize(innerWidth,innerHeight);
document.getElementById('app').appendChild(renderer.domElement);
const controls=new OrbitControls(camera, renderer.domElement); controls.enableDamping=true;

/* Lights */
scene.add(new THREE.HemisphereLight(0xffffff,0x091018,0.95));
scene.add(new THREE.AmbientLight(0xffffff,0.35));
const key=new THREE.DirectionalLight(0xffffff,1.0); key.position.set(3,5,4); scene.add(key);

/* World */
const world=new THREE.Group(); scene.add(world);
let torusGuide=null, bandMesh=null;

/* Torus mapping */
function torusPos(u,v){
  const cu=Math.cos(u), su=Math.sin(u), cv=Math.cos(v), sv=Math.sin(v);
  return new THREE.Vector3( (R + r*cv)*cu, (R + r*cv)*su, r*sv );
}
function torusPartials(u,v){
  const cu=Math.cos(u), su=Math.sin(u), cv=Math.cos(v), sv=Math.sin(v);
  const Xu=new THREE.Vector3( -(R+r*cv)*su, (R+r*cv)*cu, 0 );
  const Xv=new THREE.Vector3( -r*sv*cu, -r*sv*su, r*cv );
  return {Xu,Xv};
}

/* φ-spiral in parameter space (turns=2) */
function uvCurve(theta, kScale, v0, uScale){
  const k=k_phi*kScale;
  const v = Math.PI - (Math.PI - v0)*Math.exp(-k*theta);
  const u = uScale*theta;
  return {u,v};
}
function uvTangent(theta, kScale, v0, uScale){
  const k=k_phi*kScale;
  return {du:uScale, dv:(Math.PI - v0)*k*Math.exp(-k*theta)};
}

/* Build the single band */
let colorAttr=null, tLenAttr=null, mat=null;
function buildBand(){
  if(bandMesh){ world.remove(bandMesh); bandMesh.geometry.dispose(); mat?.dispose(); bandMesh=null; colorAttr=null; tLenAttr=null; }
  if(torusGuide){ world.remove(torusGuide); torusGuide.geometry.dispose(); torusGuide.material.dispose(); torusGuide=null; }

  const kScale=1.0, v0=0.12, uScale=+ui.uScale.value;
  const seg=2600, N=Math.max(300,seg);
  const W=16;                   // width samples
  const thetaMax=TWO_PI*TURNS;

  if(ui.showTorus.checked){
    torusGuide=new THREE.Mesh(new THREE.TorusGeometry(R,r,64,256),
      new THREE.MeshBasicMaterial({wireframe:true,color:0x355a82,transparent:true,opacity:0.28}));
    world.add(torusGuide);
  }

  const verts=[],norms=[],uvs=[],tLen=[],indices=[],colors=[];
  for(let i=0;i<=N;i++){
    const t=i/N, th=thetaMax*t;
    const {u,v}=uvCurve(th,kScale,v0,uScale);
    const {du,dv}=uvTangent(th,kScale,v0,uScale);

    // metric-orthogonal direction in (u,v) normalized to world length
    const E=(R + r*Math.cos(v))**2, G=r*r;
    const nu=-G*dv, nv=E*du;
    const nLen=Math.sqrt(E*nu*nu + G*nv*nv);
    const nuN=nu/nLen, nvN=nv/nLen;

    // world width: 0 .. WMAX based on outer-ness (cos v)
    const w = WMAX * (1 + Math.cos(v)) * 0.5;

    for(let j=0;j<=W;j++){
      const s=(j/W - 0.5);
      const u2=u + s*w*nuN;
      const v2=v + s*w*nvN;

      const P=torusPos(u2,v2);
      const {Xu:ux,Xv:vx}=torusPartials(u2,v2);
      const Nsurf=vx.clone().cross(ux).normalize();

      verts.push(P.x,P.y,P.z);
      norms.push(Nsurf.x,Nsurf.y,Nsurf.z);
      uvs.push(j/W, t);
      tLen.push(t);

      // initial color (will be animated)
      colors.push(1,1,1);
    }

    if(i<N){
      for(let j=0;j<W;j++){
        const a=(W+1)*i + j, b=(W+1)*(i+1) + j, c=(W+1)*(i+1) + j+1, d=(W+1)*i + j+1;
        indices.push(a,b,d, b,c,d);
      }
    }
  }

  const geom=new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(verts),3));
  geom.setAttribute('normal',   new THREE.Float32BufferAttribute(new Float32Array(norms),3));
  geom.setAttribute('uv',       new THREE.Float32BufferAttribute(new Float32Array(uvs),2));
  geom.setAttribute('tLen',     new THREE.Float32BufferAttribute(new Float32Array(tLen),1));
  colorAttr=new THREE.Float32BufferAttribute(new Float32Array(colors),3);
  geom.setAttribute('color', colorAttr);
  geom.setIndex(indices);
  geom.computeVertexNormals();

  mat=new THREE.MeshStandardMaterial({
    vertexColors:true, metalness:0.25, roughness:0.38,
    side:THREE.DoubleSide, transparent:true, opacity:+ui.opacity.value
  });
  // Better blending when semi-transparent
  mat.depthWrite = (+ui.opacity.value>=0.999);

  bandMesh=new THREE.Mesh(geom, mat);
  world.add(bandMesh);

  tLenAttr=geom.getAttribute('tLen');

  // color once at build
  updateColors(0);
  syncOut();
}

/* Animate color ramp along length with a phase that advances over time */
function updateColors(hPhase){
  if(!colorAttr || !tLenAttr) return;
  const col=new THREE.Color();
  const n=tLenAttr.count;
  for(let i=0;i<n;i++){
    const t=tLenAttr.getX(i);
    const h=(t + hPhase)%1;
    col.setHSL(h, 1.0, 0.55);
    colorAttr.setXYZ(i, col.r, col.g, col.b);
  }
  colorAttr.needsUpdate=true;
}

/* Views */
function resetView(){ camera.position.set(4.8,3.8,5.0); controls.target.set(0,0,0); controls.update(); }
function lookZ(){ camera.position.set(0,0,7.2); controls.target.set(0,0,0); controls.update(); }
function lookX(){ camera.position.set(7.2,0,0); controls.target.set(0,0,0); controls.update(); }
function lookY(){ camera.position.set(0,7.2,0); controls.target.set(0,0,0); controls.update(); }

/* Wire UI */
['uScale','showTorus'].forEach(id=>$(id).addEventListener('input', buildBand));
ui.opacity.addEventListener('input', ()=>{
  if(mat){ mat.opacity=+ui.opacity.value; mat.depthWrite=(+ui.opacity.value>=0.999); }
  syncOut();
});
ui.spinSpeed.addEventListener('input', syncOut);
ui.hueSpeed.addEventListener('input', syncOut);

ui.resetView.addEventListener('click', resetView);
ui.lookZ.addEventListener('click', lookZ);
ui.lookX.addEventListener('click', lookX);
ui.lookY.addEventListener('click', lookY);

/* Start + animate */
buildBand(); resetView();
const clock=new THREE.Clock();
let huePhase=0; // 0..1
function tick(){
  const dt=clock.getDelta();
  const spinΩ=(+ui.spinSpeed.value)*Math.PI/180;
  const hueΩ=(+ui.hueSpeed.value)/360; // degrees/sec -> hue cycles/sec

  if(spinΩ>0){ world.rotation.z += spinΩ*dt; }
  if(hueΩ>0){
    huePhase = (huePhase + hueΩ*dt) % 1;
    updateColors(huePhase);
  }

  controls.update(); renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
tick();

/* Resize */
addEventListener('resize', ()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
